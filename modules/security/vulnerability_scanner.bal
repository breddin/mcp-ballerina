// Vulnerability Scanner for Ballerina Projects
// Scans dependencies and code for known vulnerabilities

import ballerina/http;
import ballerina/log;
import ballerina/regex;
import ballerina/time;

// Vulnerability information
public type Vulnerability record {|
    string id;
    string source; // "CVE", "GHSA", "OSVDB", "SNYK"
    string title;
    string description;
    Severity severity;
    decimal cvssScore?;
    string[] affectedVersions;
    string? fixedVersion?;
    string[] references;
    string[] cwe;
    time:Utc publishedDate;
    time:Utc? modifiedDate?;
|};

// Dependency information
public type Dependency record {|
    string name;
    string version;
    string? group?;
    string? scope?;
    boolean direct;
    Dependency[] transitive = [];
    Vulnerability[] vulnerabilities = [];
|};

// OWASP Top 10 category
public enum OwaspCategory {
    A01_BROKEN_ACCESS_CONTROL,
    A02_CRYPTOGRAPHIC_FAILURES,
    A03_INJECTION,
    A04_INSECURE_DESIGN,
    A05_SECURITY_MISCONFIGURATION,
    A06_VULNERABLE_COMPONENTS,
    A07_AUTH_FAILURES,
    A08_DATA_INTEGRITY_FAILURES,
    A09_LOGGING_FAILURES,
    A10_SSRF
}

// Scan configuration
public type VulnerabilityScanConfig record {|
    boolean scanDependencies = true;
    boolean scanDevDependencies = false;
    boolean includeTransitive = true;
    boolean checkCVE = true;
    boolean checkGHSA = true;
    Severity minSeverity = LOW;
    decimal? maxCvssScore?;
    string[] ignoreCVEs = [];
    string[] ignorePackages = [];
|};

// Vulnerability scan result
public type VulnerabilityScanResult record {|
    boolean success;
    Dependency[] dependencies;
    Vulnerability[] vulnerabilities;
    VulnerabilityMetrics metrics;
    OwaspMapping[] owaspMappings;
    time:Utc scanTime;
|};

// Vulnerability metrics
public type VulnerabilityMetrics record {|
    int totalDependencies;
    int vulnerableDependencies;
    int totalVulnerabilities;
    int criticalCount;
    int highCount;
    int mediumCount;
    int lowCount;
    decimal averageCvss;
    decimal maxCvss;
|};

// OWASP mapping
public type OwaspMapping record {|
    OwaspCategory category;
    Vulnerability[] vulnerabilities;
    int count;
|};

// Package manifest
public type PackageManifest record {|
    string name;
    string version;
    map<string> dependencies;
    map<string>? devDependencies?;
|};

// Vulnerability database entry
public type VulnerabilityDatabase record {|
    map<Vulnerability[]> cveDatabase;
    map<Vulnerability[]> ghsaDatabase;
    time:Utc lastUpdated;
|};

// Vulnerability Scanner
public class VulnerabilityScanner {
    private VulnerabilityScanConfig config;
    private http:Client? nvdClient;
    private http:Client? ghsaClient;
    private VulnerabilityDatabase vulnDb;
    private map<Dependency> dependencyCache = {};
    
    public function init(VulnerabilityScanConfig? config = ()) {
        self.config = config ?: {};
        self.vulnDb = {
            cveDatabase: {},
            ghsaDatabase: {},
            lastUpdated: time:utcNow()
        };
        
        // Initialize vulnerability database clients
        if self.config.checkCVE {
            self.nvdClient = new("https://services.nvd.nist.gov");
        }
        if self.config.checkGHSA {
            self.ghsaClient = new("https://api.github.com");
        }
    }
    
    // Scan project for vulnerabilities
    public function scanProject(string projectPath) returns VulnerabilityScanResult|error {
        time:Utc startTime = time:utcNow();
        
        // Load package manifest
        PackageManifest manifest = check self.loadManifest(projectPath);
        
        // Scan dependencies
        Dependency[] dependencies = [];
        if self.config.scanDependencies {
            dependencies = check self.scanDependencies(manifest.dependencies, true);
        }
        
        // Scan dev dependencies
        if self.config.scanDevDependencies && manifest.devDependencies is map<string> {
            Dependency[] devDeps = check self.scanDependencies(
                <map<string>>manifest.devDependencies, false);
            dependencies.push(...devDeps);
        }
        
        // Collect all vulnerabilities
        Vulnerability[] allVulnerabilities = self.collectVulnerabilities(dependencies);
        
        // Filter vulnerabilities
        Vulnerability[] filteredVulns = self.filterVulnerabilities(allVulnerabilities);
        
        // Map to OWASP categories
        OwaspMapping[] owaspMappings = self.mapToOwasp(filteredVulns);
        
        // Calculate metrics
        VulnerabilityMetrics metrics = self.calculateMetrics(dependencies, filteredVulns);
        
        return {
            success: true,
            dependencies: dependencies,
            vulnerabilities: filteredVulns,
            metrics: metrics,
            owaspMappings: owaspMappings,
            scanTime: startTime
        };
    }
    
    // Load package manifest
    private function loadManifest(string projectPath) returns PackageManifest|error {
        // Load Ballerina.toml
        string manifestPath = projectPath + "/Ballerina.toml";
        // Parse TOML file (simplified)
        return {
            name: "sample-project",
            version: "1.0.0",
            dependencies: {
                "ballerina/http": "2.9.0",
                "ballerina/sql": "1.10.0",
                "ballerina/jwt": "2.9.0"
            }
        };
    }
    
    // Scan dependencies
    private function scanDependencies(map<string> deps, boolean direct) 
        returns Dependency[]|error {
        
        Dependency[] dependencies = [];
        
        foreach [string, string] [name, version] in deps.entries() {
            // Check cache
            string depKey = name + "@" + version;
            if self.dependencyCache.hasKey(depKey) {
                dependencies.push(self.dependencyCache[depKey]);
                continue;
            }
            
            Dependency dep = {
                name: name,
                version: version,
                direct: direct
            };
            
            // Check for vulnerabilities
            if self.config.checkCVE {
                Vulnerability[] cveVulns = check self.checkCVE(name, version);
                dep.vulnerabilities.push(...cveVulns);
            }
            
            if self.config.checkGHSA {
                Vulnerability[] ghsaVulns = check self.checkGHSA(name, version);
                dep.vulnerabilities.push(...ghsaVulns);
            }
            
            // Scan transitive dependencies
            if self.config.includeTransitive {
                dep.transitive = check self.getTransitiveDependencies(name, version);
            }
            
            self.dependencyCache[depKey] = dep;
            dependencies.push(dep);
        }
        
        return dependencies;
    }
    
    // Check CVE database
    private function checkCVE(string packageName, string version) 
        returns Vulnerability[]|error {
        
        Vulnerability[] vulnerabilities = [];
        
        // Check local cache first
        string cacheKey = packageName + "@" + version;
        if self.vulnDb.cveDatabase.hasKey(cacheKey) {
            return self.vulnDb.cveDatabase[cacheKey];
        }
        
        // Query NVD API (simplified)
        if self.nvdClient is http:Client {
            // API call to NVD
            // Parse response and create Vulnerability records
            
            // Example vulnerability
            if packageName == "ballerina/http" && version < "2.9.0" {
                vulnerabilities.push({
                    id: "CVE-2023-12345",
                    source: "CVE",
                    title: "HTTP Header Injection",
                    description: "HTTP header injection vulnerability in versions before 2.9.0",
                    severity: HIGH,
                    cvssScore: 7.5,
                    affectedVersions: ["< 2.9.0"],
                    fixedVersion: "2.9.0",
                    references: ["https://nvd.nist.gov/vuln/detail/CVE-2023-12345"],
                    cwe: ["CWE-113"],
                    publishedDate: time:utcNow()
                });
            }
        }
        
        // Cache results
        self.vulnDb.cveDatabase[cacheKey] = vulnerabilities;
        
        return vulnerabilities;
    }
    
    // Check GitHub Security Advisory
    private function checkGHSA(string packageName, string version) 
        returns Vulnerability[]|error {
        
        Vulnerability[] vulnerabilities = [];
        
        // Check local cache
        string cacheKey = packageName + "@" + version;
        if self.vulnDb.ghsaDatabase.hasKey(cacheKey) {
            return self.vulnDb.ghsaDatabase[cacheKey];
        }
        
        // Query GitHub API
        if self.ghsaClient is http:Client {
            // API call to GitHub Security Advisory
            // Parse response
            
            // Example vulnerability
            if packageName == "ballerina/jwt" && version < "2.9.0" {
                vulnerabilities.push({
                    id: "GHSA-xxxx-yyyy-zzzz",
                    source: "GHSA",
                    title: "JWT Signature Bypass",
                    description: "JWT signature bypass in versions before 2.9.0",
                    severity: CRITICAL,
                    cvssScore: 9.8,
                    affectedVersions: ["< 2.9.0"],
                    fixedVersion: "2.9.0",
                    references: ["https://github.com/advisories/GHSA-xxxx-yyyy-zzzz"],
                    cwe: ["CWE-347"],
                    publishedDate: time:utcNow()
                });
            }
        }
        
        // Cache results
        self.vulnDb.ghsaDatabase[cacheKey] = vulnerabilities;
        
        return vulnerabilities;
    }
    
    // Get transitive dependencies
    private function getTransitiveDependencies(string packageName, string version) 
        returns Dependency[]|error {
        
        // Query package registry for transitive dependencies
        // This would typically involve calling Ballerina Central API
        return [];
    }
    
    // Collect all vulnerabilities
    private function collectVulnerabilities(Dependency[] dependencies) 
        returns Vulnerability[] {
        
        Vulnerability[] allVulns = [];
        
        foreach Dependency dep in dependencies {
            allVulns.push(...dep.vulnerabilities);
            
            // Include transitive vulnerabilities
            foreach Dependency transitive in dep.transitive {
                allVulns.push(...transitive.vulnerabilities);
            }
        }
        
        return allVulns;
    }
    
    // Filter vulnerabilities
    private function filterVulnerabilities(Vulnerability[] vulnerabilities) 
        returns Vulnerability[] {
        
        Vulnerability[] filtered = [];
        
        foreach Vulnerability vuln in vulnerabilities {
            // Filter by severity
            if self.compareSeverity(vuln.severity, self.config.minSeverity) < 0 {
                continue;
            }
            
            // Filter by CVSS score
            if self.config.maxCvssScore is decimal {
                decimal maxScore = <decimal>self.config.maxCvssScore;
                if vuln.cvssScore is decimal && vuln.cvssScore > maxScore {
                    continue;
                }
            }
            
            // Filter ignored CVEs
            if self.config.ignoreCVEs.indexOf(vuln.id) != () {
                continue;
            }
            
            filtered.push(vuln);
        }
        
        return filtered;
    }
    
    // Map vulnerabilities to OWASP Top 10
    private function mapToOwasp(Vulnerability[] vulnerabilities) returns OwaspMapping[] {
        map<Vulnerability[]> owaspMap = {};
        
        foreach Vulnerability vuln in vulnerabilities {
            OwaspCategory? category = self.getOwaspCategory(vuln.cwe);
            if category is OwaspCategory {
                string key = category.toString();
                if !owaspMap.hasKey(key) {
                    owaspMap[key] = [];
                }
                owaspMap[key].push(vuln);
            }
        }
        
        OwaspMapping[] mappings = [];
        foreach [string, Vulnerability[]] [category, vulns] in owaspMap.entries() {
            mappings.push({
                category: self.parseOwaspCategory(category),
                vulnerabilities: vulns,
                count: vulns.length()
            });
        }
        
        return mappings;
    }
    
    // Get OWASP category from CWE
    private function getOwaspCategory(string[] cweIds) returns OwaspCategory? {
        foreach string cwe in cweIds {
            match cwe {
                "CWE-89"|"CWE-90"|"CWE-113" => { return A03_INJECTION; }
                "CWE-287"|"CWE-306"|"CWE-384" => { return A07_AUTH_FAILURES; }
                "CWE-310"|"CWE-327"|"CWE-328" => { return A02_CRYPTOGRAPHIC_FAILURES; }
                "CWE-285"|"CWE-862"|"CWE-863" => { return A01_BROKEN_ACCESS_CONTROL; }
                "CWE-16"|"CWE-20" => { return A04_INSECURE_DESIGN; }
                "CWE-200"|"CWE-209" => { return A09_LOGGING_FAILURES; }
                "CWE-918" => { return A10_SSRF; }
                _ => {}
            }
        }
        
        // Default to vulnerable components for dependency vulnerabilities
        return A06_VULNERABLE_COMPONENTS;
    }
    
    // Parse OWASP category string
    private function parseOwaspCategory(string cat) returns OwaspCategory {
        // Parse string back to enum
        match cat {
            "A01_BROKEN_ACCESS_CONTROL" => { return A01_BROKEN_ACCESS_CONTROL; }
            "A02_CRYPTOGRAPHIC_FAILURES" => { return A02_CRYPTOGRAPHIC_FAILURES; }
            "A03_INJECTION" => { return A03_INJECTION; }
            "A04_INSECURE_DESIGN" => { return A04_INSECURE_DESIGN; }
            "A05_SECURITY_MISCONFIGURATION" => { return A05_SECURITY_MISCONFIGURATION; }
            "A06_VULNERABLE_COMPONENTS" => { return A06_VULNERABLE_COMPONENTS; }
            "A07_AUTH_FAILURES" => { return A07_AUTH_FAILURES; }
            "A08_DATA_INTEGRITY_FAILURES" => { return A08_DATA_INTEGRITY_FAILURES; }
            "A09_LOGGING_FAILURES" => { return A09_LOGGING_FAILURES; }
            "A10_SSRF" => { return A10_SSRF; }
            _ => { return A06_VULNERABLE_COMPONENTS; }
        }
    }
    
    // Calculate metrics
    private function calculateMetrics(Dependency[] dependencies, Vulnerability[] vulnerabilities) 
        returns VulnerabilityMetrics {
        
        int vulnerableDeps = 0;
        foreach Dependency dep in dependencies {
            if dep.vulnerabilities.length() > 0 {
                vulnerableDeps += 1;
            }
        }
        
        int critical = 0, high = 0, medium = 0, low = 0;
        decimal totalCvss = 0.0;
        decimal maxCvss = 0.0;
        int cvssCount = 0;
        
        foreach Vulnerability vuln in vulnerabilities {
            match vuln.severity {
                CRITICAL => { critical += 1; }
                HIGH => { high += 1; }
                MEDIUM => { medium += 1; }
                LOW => { low += 1; }
            }
            
            if vuln.cvssScore is decimal {
                decimal score = <decimal>vuln.cvssScore;
                totalCvss += score;
                cvssCount += 1;
                if score > maxCvss {
                    maxCvss = score;
                }
            }
        }
        
        decimal avgCvss = cvssCount > 0 ? totalCvss / <decimal>cvssCount : 0.0;
        
        return {
            totalDependencies: dependencies.length(),
            vulnerableDependencies: vulnerableDeps,
            totalVulnerabilities: vulnerabilities.length(),
            criticalCount: critical,
            highCount: high,
            mediumCount: medium,
            lowCount: low,
            averageCvss: avgCvss,
            maxCvss: maxCvss
        };
    }
    
    // Compare severity levels
    private function compareSeverity(Severity s1, Severity s2) returns int {
        int[] severityValues = [5, 4, 3, 2, 1]; // CRITICAL to INFO
        int v1 = severityValues[<int>s1];
        int v2 = severityValues[<int>s2];
        return v1 - v2;
    }
    
    // Update vulnerability database
    public function updateDatabase() returns error? {
        log:printInfo("Updating vulnerability database...");
        
        // Fetch latest CVE data
        if self.config.checkCVE && self.nvdClient is http:Client {
            // Fetch from NVD API
            // Update self.vulnDb.cveDatabase
        }
        
        // Fetch latest GHSA data
        if self.config.checkGHSA && self.ghsaClient is http:Client {
            // Fetch from GitHub API
            // Update self.vulnDb.ghsaDatabase
        }
        
        self.vulnDb.lastUpdated = time:utcNow();
        log:printInfo("Vulnerability database updated");
        
        return;
    }
    
    // Get vulnerability by ID
    public function getVulnerability(string vulnId) returns Vulnerability? {
        // Search in CVE database
        foreach [string, Vulnerability[]] [_, vulns] in self.vulnDb.cveDatabase.entries() {
            foreach Vulnerability vuln in vulns {
                if vuln.id == vulnId {
                    return vuln;
                }
            }
        }
        
        // Search in GHSA database
        foreach [string, Vulnerability[]] [_, vulns] in self.vulnDb.ghsaDatabase.entries() {
            foreach Vulnerability vuln in vulns {
                if vuln.id == vulnId {
                    return vuln;
                }
            }
        }
        
        return ();
    }
    
    // Check if version is affected
    public function isVersionAffected(string version, string[] affectedVersions) 
        returns boolean {
        
        foreach string affected in affectedVersions {
            if self.matchesVersionPattern(version, affected) {
                return true;
            }
        }
        
        return false;
    }
    
    // Match version pattern
    private function matchesVersionPattern(string version, string pattern) returns boolean {
        // Handle version range patterns like "< 2.9.0", ">= 1.0.0", "1.x"
        if pattern.startsWith("<") {
            string targetVersion = pattern.substring(1).trim();
            return self.compareVersions(version, targetVersion) < 0;
        } else if pattern.startsWith("<=") {
            string targetVersion = pattern.substring(2).trim();
            return self.compareVersions(version, targetVersion) <= 0;
        } else if pattern.startsWith(">") {
            string targetVersion = pattern.substring(1).trim();
            return self.compareVersions(version, targetVersion) > 0;
        } else if pattern.startsWith(">=") {
            string targetVersion = pattern.substring(2).trim();
            return self.compareVersions(version, targetVersion) >= 0;
        } else if pattern.endsWith(".x") {
            string prefix = pattern.substring(0, pattern.length() - 2);
            return version.startsWith(prefix);
        }
        
        return version == pattern;
    }
    
    // Compare semantic versions
    private function compareVersions(string v1, string v2) returns int {
        string[] parts1 = regex:split(v1, "\\.");
        string[] parts2 = regex:split(v2, "\\.");
        
        int maxLength = parts1.length() > parts2.length() ? parts1.length() : parts2.length();
        
        foreach int i in 0 ..< maxLength {
            int p1 = i < parts1.length() ? (int:fromString(parts1[i]) ?: 0) : 0;
            int p2 = i < parts2.length() ? (int:fromString(parts2[i]) ?: 0) : 0;
            
            if p1 < p2 {
                return -1;
            } else if p1 > p2 {
                return 1;
            }
        }
        
        return 0;
    }
}